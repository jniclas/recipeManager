/**
 * generated by Xtext 2.12.0
 */
package org.xtext.example.mydsl.validation;

import com.google.common.base.Objects;
import org.eclipse.emf.common.util.EList;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.xtext.example.mydsl.myDsl.Author;
import org.xtext.example.mydsl.myDsl.Ingredient;
import org.xtext.example.mydsl.myDsl.MyDslPackage;
import org.xtext.example.mydsl.myDsl.Rating;
import org.xtext.example.mydsl.myDsl.Recipe;
import org.xtext.example.mydsl.myDsl.RecipeManager;
import org.xtext.example.mydsl.validation.AbstractMyDslValidator;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class MyDslValidator extends AbstractMyDslValidator {
  @Check
  public void recipeManagerExists(final RecipeManager recipeManager) {
    if ((recipeManager == null)) {
      this.error("Please add a recipe manager, by starting with an author!", 
        MyDslPackage.Literals.RECIPE__AUTHOR);
    }
  }
  
  @Check
  public void recipeWithAuthorExists(final Recipe recipe) {
    Author _author = recipe.getAuthor();
    boolean _tripleEquals = (_author == null);
    if (_tripleEquals) {
      this.error("Please add an author!", 
        MyDslPackage.Literals.RECIPE__AUTHOR);
    }
  }
  
  @Check
  public void recipeExists(final Recipe recipe) {
    if ((recipe == null)) {
      this.error("Please add a recipe!", 
        MyDslPackage.Literals.RECIPE__NAME);
    }
  }
  
  @Check
  public void NoSelfRating(final Recipe recipe) {
    EList<Rating> ratings = recipe.getRatings();
    for (int i = 0; (i < ((Object[])Conversions.unwrapArray(ratings, Object.class)).length); i++) {
      boolean _equals = ratings.get(i).getAuthor().equals(recipe.getAuthor());
      if (_equals) {
        this.error("Self rating is not allowed!", 
          MyDslPackage.Literals.RECIPE__RATINGS, i);
      }
    }
  }
  
  @Check
  public void onlyOneRatingPerRecipeByAuthor(final Recipe recipe) {
    EList<Rating> ratings = recipe.getRatings();
    for (int i = 0; (i < ((Object[])Conversions.unwrapArray(ratings, Object.class)).length); i++) {
      {
        Author author1 = ratings.get(i).getAuthor();
        for (int j = (i + 1); (i < ((Object[])Conversions.unwrapArray(ratings, Object.class)).length); i++) {
          {
            Author author2 = ratings.get(j).getAuthor();
            boolean _equals = author1.equals(author2);
            if (_equals) {
              this.error("You can only make one rating per recipe!", 
                MyDslPackage.Literals.RECIPE__RATINGS, j);
            }
          }
        }
      }
    }
  }
  
  @Check
  public void recipeNotContainingItSelf(final Recipe recipe) {
    String recipeName = recipe.getName();
    EList<Ingredient> ingredients = recipe.getIngredient();
    for (int i = 0; (i < ((Object[])Conversions.unwrapArray(ingredients, Object.class)).length); i++) {
      {
        Ingredient ingredient = ingredients.get(i);
        String _name = ingredient.getName();
        boolean _tripleEquals = (_name == null);
        if (_tripleEquals) {
          String ingredientName = ingredient.getRecipe().getName();
          boolean _equals = recipeName.equals(ingredientName);
          if (_equals) {
            this.error("A recipe must not contain itself!", 
              MyDslPackage.Literals.RECIPE__INGREDIENT, i);
          }
        }
      }
    }
  }
  
  @Check
  public void recipeHasAuthor(final Recipe recipe) {
    Author _author = recipe.getAuthor();
    boolean _tripleEquals = (_author == null);
    if (_tripleEquals) {
      this.error("Every recipe must have an author!", 
        MyDslPackage.Literals.RECIPE__AUTHOR);
    }
  }
  
  @Check
  public void recipeHasIngredient(final Recipe recipe) {
    EList<Ingredient> _ingredient = recipe.getIngredient();
    boolean _tripleEquals = (_ingredient == null);
    if (_tripleEquals) {
      this.error("Every recipe must have an ingredient!", 
        MyDslPackage.Literals.RECIPE__INGREDIENT);
    }
  }
  
  @Check
  public void recipeIsIngredientOfRecipe(final Recipe recipe) {
    EList<Ingredient> ingredients = recipe.getIngredient();
    final EList<Ingredient> _converted_ingredients = (EList<Ingredient>)ingredients;
    int _length = ((Object[])Conversions.unwrapArray(_converted_ingredients, Object.class)).length;
    boolean _equals = (_length == 1);
    if (_equals) {
      String ingredientName = ingredients.get(0).getName();
      if ((ingredientName == null)) {
        this.error("A recipe must not copy another recipe! Please add a second ingredient", 
          MyDslPackage.Literals.RECIPE__INGREDIENT);
      }
    }
  }
  
  @Check
  public void veganRecipeHasVegetaricIngredient(final Recipe recipe) {
    String _vegan = recipe.getVegan();
    boolean _equals = Objects.equal(_vegan, "Vegan");
    if (_equals) {
      EList<Ingredient> ingredients = recipe.getIngredient();
      for (int i = 0; (i < ((Object[])Conversions.unwrapArray(ingredients, Object.class)).length); i++) {
        {
          Ingredient ingredient = ingredients.get(i);
          String veganismLevel = ingredient.getVeganismLevel();
          boolean _equals_1 = veganismLevel.equals("Vegatric");
          if (_equals_1) {
            this.error("A vegan recipe cannot contain a non-vegetaric ingredient!", 
              MyDslPackage.Literals.RECIPE__INGREDIENT, i);
          }
        }
      }
    }
  }
  
  @Check
  public void veganRecipeHasCanivorousRecipe(final Recipe recipe) {
    String _vegan = recipe.getVegan();
    boolean _equals = Objects.equal(_vegan, "Vegan");
    if (_equals) {
      EList<Ingredient> ingredients = recipe.getIngredient();
      for (int i = 0; (i < ((Object[])Conversions.unwrapArray(ingredients, Object.class)).length); i++) {
        {
          Ingredient ingredient = ingredients.get(i);
          String veganismLevel = ingredient.getVeganismLevel();
          if ((veganismLevel == null)) {
            try {
              veganismLevel = ingredient.getRecipe().getVegan();
            } catch (final Throwable _t) {
              if (_t instanceof Error) {
                final Error e = (Error)_t;
              } else {
                throw Exceptions.sneakyThrow(_t);
              }
            }
          } else {
            veganismLevel = "Vegan";
          }
          boolean _equals_1 = veganismLevel.equals("Canivorous");
          if (_equals_1) {
            this.error("A vegan recipe cannot contain a canivorous ingredient!", 
              MyDslPackage.Literals.RECIPE__INGREDIENT, i);
          }
        }
      }
    }
  }
  
  @Check
  public void veganRecipeHasVegetaricRecipe(final Recipe recipe) {
    String _vegan = recipe.getVegan();
    boolean _equals = Objects.equal(_vegan, "Vegan");
    if (_equals) {
      EList<Ingredient> ingredients = recipe.getIngredient();
      for (int i = 0; (i < ((Object[])Conversions.unwrapArray(ingredients, Object.class)).length); i++) {
        {
          Ingredient ingredient = ingredients.get(i);
          String veganismLevel = ingredient.getVeganismLevel();
          if ((veganismLevel == null)) {
            try {
              veganismLevel = ingredient.getRecipe().getVegan();
            } catch (final Throwable _t) {
              if (_t instanceof Error) {
                final Error e = (Error)_t;
              } else {
                throw Exceptions.sneakyThrow(_t);
              }
            }
          } else {
            veganismLevel = "Vegan";
          }
          boolean _equals_1 = veganismLevel.equals("Vegetaric");
          if (_equals_1) {
            this.error("A vegan recipe cannot contain a vegetaric recipe!", 
              MyDslPackage.Literals.RECIPE__INGREDIENT, i);
          }
        }
      }
    }
  }
  
  @Check
  public void vegetaricRecipeHasCanivorousRecipe(final Recipe recipe) {
    String _vegan = recipe.getVegan();
    boolean _equals = Objects.equal(_vegan, "Vegetaric");
    if (_equals) {
      EList<Ingredient> ingredients = recipe.getIngredient();
      for (int i = 0; (i < ((Object[])Conversions.unwrapArray(ingredients, Object.class)).length); i++) {
        {
          Ingredient ingredient = ingredients.get(i);
          String veganismLevel = ingredient.getVeganismLevel();
          if ((veganismLevel == null)) {
            try {
              veganismLevel = ingredient.getRecipe().getVegan();
            } catch (final Throwable _t) {
              if (_t instanceof Error) {
                final Error e = (Error)_t;
              } else {
                throw Exceptions.sneakyThrow(_t);
              }
            }
          } else {
            veganismLevel = "Vegetaric";
          }
          boolean _equals_1 = veganismLevel.equals("Canivorous");
          if (_equals_1) {
            this.error("A vegetaric recipe cannot contain canivorous recipe!", 
              MyDslPackage.Literals.RECIPE__INGREDIENT, i);
          }
        }
      }
    }
  }
  
  @Check
  public void vegetaricRecipeHasCanivorousIngredient(final Recipe recipe) {
    String _vegan = recipe.getVegan();
    boolean _equals = Objects.equal(_vegan, "Vegetaric");
    if (_equals) {
      EList<Ingredient> ingredients = recipe.getIngredient();
      for (int i = 0; (i < ((Object[])Conversions.unwrapArray(ingredients, Object.class)).length); i++) {
        {
          Ingredient ingredient = ingredients.get(i);
          String veganismLevel = ingredient.getVeganismLevel();
          boolean _equals_1 = veganismLevel.equals("Canivorous");
          if (_equals_1) {
            this.error("A vegetaric recipe cannot contain a canivorous ingredient!", 
              MyDslPackage.Literals.RECIPE__INGREDIENT, i);
          }
        }
      }
    }
  }
}
