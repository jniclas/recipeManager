/**
 * generated by Xtext 2.12.0
 */
package org.xtext.example.mydsl.validation;

import org.eclipse.emf.common.util.EList;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.xtext.example.mydsl.myDsl.Author;
import org.xtext.example.mydsl.myDsl.Ingredient;
import org.xtext.example.mydsl.myDsl.MyDslPackage;
import org.xtext.example.mydsl.myDsl.Rating;
import org.xtext.example.mydsl.myDsl.Recipe;
import org.xtext.example.mydsl.validation.AbstractMyDslValidator;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class MyDslValidator extends AbstractMyDslValidator {
  @Check
  public void NoSelfRating(final Recipe recipe) {
    EList<Rating> ratings = recipe.getRatings();
    for (int i = 0; (i < ((Object[])Conversions.unwrapArray(ratings, Object.class)).length); i++) {
      boolean _equals = ratings.get(i).getAuthor().equals(recipe.getAuthor());
      if (_equals) {
        this.error("Self rating is not allowed!", 
          MyDslPackage.Literals.RECIPE__RATINGS, i);
      }
    }
  }
  
  @Check
  public void onlyOneRatingPerRecipeByAuthor(final Recipe recipe) {
    EList<Rating> ratings = recipe.getRatings();
    for (int i = 0; (i < ((Object[])Conversions.unwrapArray(ratings, Object.class)).length); i++) {
      {
        Author author1 = ratings.get(i).getAuthor();
        for (int j = (i + 1); (i < ((Object[])Conversions.unwrapArray(ratings, Object.class)).length); i++) {
          {
            Author author2 = ratings.get(j).getAuthor();
            boolean _equals = author1.equals(author2);
            if (_equals) {
              this.error("You can only make one rating per recipe!", 
                MyDslPackage.Literals.RECIPE__RATINGS, j);
            }
          }
        }
      }
    }
  }
  
  @Check
  public void recipeNotContainingItSelf(final Recipe recipe) {
    String recipeName = recipe.getName();
    EList<Ingredient> ingredients = recipe.getIngredient();
    for (int i = 0; (i < ((Object[])Conversions.unwrapArray(ingredients, Object.class)).length); i++) {
      {
        String ingredientName = ingredients.get(i).getName();
        ingredientName = ingredientName.replaceAll("\\-\\s", "");
        ingredientName = ingredientName.replaceAll(",", "");
        boolean _equals = recipeName.equals(ingredientName);
        if (_equals) {
          this.error("A recipe cannot contain itself!", 
            MyDslPackage.Literals.RECIPE__INGREDIENT, i);
        }
      }
    }
  }
  
  @Check
  public void recipeHasAuthor(final Recipe recipe) {
    Author _author = recipe.getAuthor();
    boolean _tripleEquals = (_author == null);
    if (_tripleEquals) {
      this.error("Every recipe must have an author!", 
        MyDslPackage.Literals.RECIPE__AUTHOR);
    }
  }
  
  @Check
  public void recipeHasIngredient(final Recipe recipe) {
    EList<Ingredient> _ingredient = recipe.getIngredient();
    boolean _tripleEquals = (_ingredient == null);
    if (_tripleEquals) {
      this.error("Every recipe must have an ingredient!", 
        MyDslPackage.Literals.RECIPE__INGREDIENT);
    }
  }
  
  @Check
  public void recipeIsIngredientOfRecipe(final Recipe recipe) {
    EList<Ingredient> ingredients = recipe.getIngredient();
    final EList<Ingredient> _converted_ingredients = (EList<Ingredient>)ingredients;
    int _length = ((Object[])Conversions.unwrapArray(_converted_ingredients, Object.class)).length;
    boolean _equals = (_length == 1);
    if (_equals) {
      String ingredientName = ingredients.get(0).getName();
      if ((ingredientName == null)) {
        this.error("A recipe must not copy another recipe! Please add a second ingredient", 
          MyDslPackage.Literals.RECIPE__INGREDIENT);
      }
    }
  }
}
