/*
 * generated by Xtext 2.12.0
 */
package org.xtext.example.mydsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.mydsl.myDsl.Author;
import org.xtext.example.mydsl.myDsl.DifficultyLevel;
import org.xtext.example.mydsl.myDsl.FoodCategory;
import org.xtext.example.mydsl.myDsl.Ingredient;
import org.xtext.example.mydsl.myDsl.KitchenUtensil;
import org.xtext.example.mydsl.myDsl.MyDslPackage;
import org.xtext.example.mydsl.myDsl.Rating;
import org.xtext.example.mydsl.myDsl.Recipe;
import org.xtext.example.mydsl.myDsl.RecipeManager;
import org.xtext.example.mydsl.services.MyDslGrammarAccess;

@SuppressWarnings("all")
public class MyDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MyDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MyDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MyDslPackage.AUTHOR:
				sequence_Author(context, (Author) semanticObject); 
				return; 
			case MyDslPackage.DIFFICULTY_LEVEL:
				sequence_DifficultyLevel(context, (DifficultyLevel) semanticObject); 
				return; 
			case MyDslPackage.FOOD_CATEGORY:
				sequence_FoodCategory(context, (FoodCategory) semanticObject); 
				return; 
			case MyDslPackage.INGREDIENT:
				sequence_Ingredient(context, (Ingredient) semanticObject); 
				return; 
			case MyDslPackage.KITCHEN_UTENSIL:
				sequence_KitchenUtensil(context, (KitchenUtensil) semanticObject); 
				return; 
			case MyDslPackage.RATING:
				sequence_Rating(context, (Rating) semanticObject); 
				return; 
			case MyDslPackage.RECIPE:
				sequence_Recipe(context, (Recipe) semanticObject); 
				return; 
			case MyDslPackage.RECIPE_MANAGER:
				sequence_RecipeManager(context, (RecipeManager) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Author returns Author
	 *
	 * Constraint:
	 *     (name=ID Email=STRING)
	 */
	protected void sequence_Author(ISerializationContext context, Author semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.AUTHOR__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.AUTHOR__NAME));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.AUTHOR__EMAIL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.AUTHOR__EMAIL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAuthorAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getAuthorAccess().getEmailSTRINGTerminalRuleCall_1_0(), semanticObject.getEmail());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DifficultyLevel returns DifficultyLevel
	 *
	 * Constraint:
	 *     (name='easy' | name='medium' | name='hard')
	 */
	protected void sequence_DifficultyLevel(ISerializationContext context, DifficultyLevel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FoodCategory returns FoodCategory
	 *
	 * Constraint:
	 *     name=STRING
	 */
	protected void sequence_FoodCategory(ISerializationContext context, FoodCategory semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.FOOD_CATEGORY__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.FOOD_CATEGORY__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFoodCategoryAccess().getNameSTRINGTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Ingredient returns Ingredient
	 *
	 * Constraint:
	 *     ((name=STRING amount=INT unit=Unit veganismLevel=VeganismLevel) | recipe=[Recipe|ID])
	 */
	protected void sequence_Ingredient(ISerializationContext context, Ingredient semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KitchenUtensil returns KitchenUtensil
	 *
	 * Constraint:
	 *     (name=STRING | name='furnace' | name='stovetop' | name='rolling pin')
	 */
	protected void sequence_KitchenUtensil(ISerializationContext context, KitchenUtensil semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Rating returns Rating
	 *
	 * Constraint:
	 *     (stars=INT comment=STRING author=[Author|ID])
	 */
	protected void sequence_Rating(ISerializationContext context, Rating semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.RATING__STARS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.RATING__STARS));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.RATING__COMMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.RATING__COMMENT));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.RATING__AUTHOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.RATING__AUTHOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRatingAccess().getStarsINTTerminalRuleCall_0_0(), semanticObject.getStars());
		feeder.accept(grammarAccess.getRatingAccess().getCommentSTRINGTerminalRuleCall_2_0(), semanticObject.getComment());
		feeder.accept(grammarAccess.getRatingAccess().getAuthorAuthorIDTerminalRuleCall_4_0_1(), semanticObject.eGet(MyDslPackage.Literals.RATING__AUTHOR, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RecipeManager returns RecipeManager
	 *
	 * Constraint:
	 *     (authors+=Author authors+=Author* (recipes+=Recipe recipes+=Recipe*)?)
	 */
	protected void sequence_RecipeManager(ISerializationContext context, RecipeManager semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Recipe returns Recipe
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         author=[Author|ID] 
	 *         vegan=VeganismLevel 
	 *         duration=INT 
	 *         difficulty=DifficultyLevel 
	 *         kitchenUtensils+=KitchenUtensil 
	 *         kitchenUtensils+=KitchenUtensil* 
	 *         foodCategory+=FoodCategory 
	 *         foodCategory+=FoodCategory* 
	 *         ingredient+=Ingredient 
	 *         ingredient+=Ingredient* 
	 *         ratings+=Rating 
	 *         ratings+=Rating*
	 *     )
	 */
	protected void sequence_Recipe(ISerializationContext context, Recipe semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
